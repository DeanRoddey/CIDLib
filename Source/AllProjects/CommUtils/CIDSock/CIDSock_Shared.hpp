// ----------------------------------------------------------------------------
//  FILE: CIDSock_Shared.hpp
//  DATE: Mon, Sep 28 13:47:54 2020 -0400
//
//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make
//  changes by hand, because they will be lost if the file is regenerated.
// ----------------------------------------------------------------------------
#pragma once

#pragma CIDLIB_PACK(CIDLIBPACK)

// ----------------------------------------------------------------------------
// Types namespace
// ----------------------------------------------------------------------------
namespace tCIDSock
{
    
    // ------------------------------------------------------------------------
    //  URL encoding/expansion flags
    //                  
    // ------------------------------------------------------------------------
    enum class EExpOpts
    {
        None
        , Encode
        , Expand
        , Count
        , Min = None
        , Max = Expand
    };
    CIDSOCKEXP EExpOpts eXlatEExpOpts(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CIDSOCKEXP const TString& strXlatEExpOpts(const EExpOpts eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CIDSOCKEXP tCIDLib::TBoolean bIsValidEnum(const EExpOpts eVal);

    
    // ------------------------------------------------------------------------
    //  Our known supported internet protocols
    //                  
    // ------------------------------------------------------------------------
    enum class EProtos
    {
        None
        , File
        , HTTP
        , FTP
        , MailTo
        , News
        , HTTPS
        , RTSP
        , RTSPS
        , SIP
        , WS
        , WSS
        , Count
        , Min = None
        , Max = WSS
    };
    CIDSOCKEXP EProtos eXlatEProtos(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CIDSOCKEXP const TString& strXlatEProtos(const EProtos eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CIDSOCKEXP const TString& strAltXlatEProtos(const EProtos eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CIDSOCKEXP EProtos eAltXlatEProtos(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CIDSOCKEXP tCIDLib::TBoolean bIsValidEnum(const EProtos eVal);

    
    // ------------------------------------------------------------------------
    //  Flags for URL qualification
    //                  
    // ------------------------------------------------------------------------
    enum class EQualified
    {
        Partial
        , Full
        , DontCare
        , Count
        , Min = Partial
        , Max = DontCare
    };
    CIDSOCKEXP EQualified eXlatEQualified(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CIDSOCKEXP const TString& strXlatEQualified(const EQualified eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CIDSOCKEXP tCIDLib::TBoolean bIsValidEnum(const EQualified eVal);

    
    // ------------------------------------------------------------------------
    //  For servers that accept either secure or insecure or both types of connections
    //  this is a convenient way to store those options.
    //                  
    // ------------------------------------------------------------------------
    enum class ESecureOpts : tCIDLib::TCard4
    {
        Insecure = 0x00000001
        , Secure = 0x00000002
        , Both = 0x00000003
        , Count = 3
        , None = 0
        , AllBits = 0x3
    };
    CIDSOCKEXP ESecureOpts eXlatESecureOpts(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CIDSOCKEXP const TString& strXlatESecureOpts(const ESecureOpts eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CIDSOCKEXP tCIDLib::TBoolean bIsValidEnum(const ESecureOpts eVal);

}

#pragma CIDLIB_POPPACK

CIDSOCKEXP TBinOutStream& operator<<(TBinOutStream& strmTar, const tCIDSock::EExpOpts eToStream);
CIDSOCKEXP TBinInStream& operator>>(TBinInStream& strmSrc, tCIDSock::EExpOpts& eToFill);
CIDSOCKEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCIDSock::EExpOpts* const aeList, const tCIDLib::TCard4 c4Count);
CIDSOCKEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCIDSock::EExpOpts* const aeList, const tCIDLib::TCard4 c4Count);
CIDSOCKEXP TTextOutStream& operator<<(TTextOutStream& strmTar, const tCIDSock::EExpOpts eToStream);

CIDSOCKEXP TBinOutStream& operator<<(TBinOutStream& strmTar, const tCIDSock::EProtos eToStream);
CIDSOCKEXP TBinInStream& operator>>(TBinInStream& strmSrc, tCIDSock::EProtos& eToFill);
CIDSOCKEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCIDSock::EProtos* const aeList, const tCIDLib::TCard4 c4Count);
CIDSOCKEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCIDSock::EProtos* const aeList, const tCIDLib::TCard4 c4Count);
CIDSOCKEXP TTextOutStream& operator<<(TTextOutStream& strmTar, const tCIDSock::EProtos eToStream);

CIDSOCKEXP TBinOutStream& operator<<(TBinOutStream& strmTar, const tCIDSock::EQualified eToStream);
CIDSOCKEXP TBinInStream& operator>>(TBinInStream& strmSrc, tCIDSock::EQualified& eToFill);
CIDSOCKEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCIDSock::EQualified* const aeList, const tCIDLib::TCard4 c4Count);
CIDSOCKEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCIDSock::EQualified* const aeList, const tCIDLib::TCard4 c4Count);
CIDSOCKEXP TTextOutStream& operator<<(TTextOutStream& strmTar, const tCIDSock::EQualified eToStream);

CIDSOCKEXP TBinOutStream& operator<<(TBinOutStream& strmTar, const tCIDSock::ESecureOpts eToStream);
CIDSOCKEXP TBinInStream& operator>>(TBinInStream& strmSrc, tCIDSock::ESecureOpts& eToFill);
CIDSOCKEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCIDSock::ESecureOpts* const aeList, const tCIDLib::TCard4 c4Count);
CIDSOCKEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCIDSock::ESecureOpts* const aeList, const tCIDLib::TCard4 c4Count);
constexpr tCIDSock::ESecureOpts operator|(const tCIDSock::ESecureOpts eLHS, const tCIDSock::ESecureOpts eRHS)
{    
    return tCIDSock::ESecureOpts(tCIDLib::TEnumMaskType(eLHS) | tCIDLib::TEnumMaskType(eRHS));
}
constexpr tCIDSock::ESecureOpts& operator|=(tCIDSock::ESecureOpts& eLHS, const tCIDSock::ESecureOpts eRHS)
{    
    eLHS = tCIDSock::ESecureOpts(tCIDLib::TEnumMaskType(eLHS) | tCIDLib::TEnumMaskType(eRHS));
    return eLHS;
}
constexpr tCIDSock::ESecureOpts operator&(const tCIDSock::ESecureOpts eLHS, const tCIDSock::ESecureOpts eRHS)
{    
    return tCIDSock::ESecureOpts(tCIDLib::TEnumMaskType(eLHS) & tCIDLib::TEnumMaskType(eRHS));
}
constexpr tCIDSock::ESecureOpts& operator&=(tCIDSock::ESecureOpts& eLHS, const tCIDSock::ESecureOpts eRHS)
{    
    eLHS = tCIDSock::ESecureOpts(tCIDLib::TEnumMaskType(eLHS) & tCIDLib::TEnumMaskType(eRHS));
    return eLHS;
}
CIDSOCKEXP TTextOutStream& operator<<(TTextOutStream& strmTar, const tCIDSock::ESecureOpts eToStream);

