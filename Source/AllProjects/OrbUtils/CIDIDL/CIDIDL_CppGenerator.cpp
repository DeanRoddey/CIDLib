//
// FILE NAME: CIDIDL_CppGenerator.cpp
//
// AUTHOR: Dean Roddey
//
// CREATED: 08/10/2004
//
// COPYRIGHT: Charmed Quark Systems, Ltd @ 2019
//
//  This software is copyrighted by 'Charmed Quark Systems, Ltd' and
//  the author (Dean Roddey.) It is licensed under the MIT Open Source
//  license:
//
//  https://opensource.org/licenses/MIT
//
// DESCRIPTION:
//
//  This file implements the Cpp code generator derivative. We handle spitting
//  out code for C++ bindings.
//
// CAVEATS/GOTCHAS:
//
// LOG:
//
//  $_CIDLib_Log_$
//


// ---------------------------------------------------------------------------
//  Includes
// ---------------------------------------------------------------------------
#include    "CIDIDL.hpp"


// ---------------------------------------------------------------------------
//  Magic macros
// ---------------------------------------------------------------------------
RTTIDecls(TCppGenerator,TCodeGenerator)



// ---------------------------------------------------------------------------
//  Local data
// ---------------------------------------------------------------------------
namespace CIDIDL_CppGenerator
{
    //
    //  Much of the output to the generated Cpp files will be exactly the
    //  same. It just differs in the names of the specific classes and such.
    //  So we create templates of them here, and use the standard token
    //  replacement system of CIDLib to replace the tokens at runtime.
    //
    //  A simple loop can be used to run through each line, search for tokens,
    //  replace them, and write out the results. This massively cuts down on
    //  the amount of grunt code used to generate the code.
    //
    //  The tokens are:
    //
    //  %(C)    The name of the target class
    //  %(c)    The name of the client class
    //  %(s)    The name of the server class
    //  %(I)    The interface id
    //  %(T)    The timestamp
    //  %(F)    The name of the file
    //  %(f)    The name of the facility being generated into
    //  %(E)    The export keyword for the current client/server mode
    //  %(B)    The base class for the current client/server mode
    //  %(P)    Type/name string for passthrough parms
    //  %(p)    Name string for passthrough parms
    //  %(N)    This is %(P) with a leading comma
    //  %(n)    This is %(p) with a leading comma
    //  %(h)    The facility include file
    //              Could be private or public, accoriding to settings
    //
    //  The client side header templates. We have one that gets us down to the
    //  static data, and then the static data is inserted. Then we go down to
    //  where the methods are inserted, then we finish it off in part three.
    //
    const tCIDLib::TCh* const pszClientHeader1 =
    L"// ----------------------------------------------------------------------------\n"
    L"//  FILE: %(F)\n"
    L"//  DATE: %(T)\n"
    L"//    ID: %(I)\n"
    L"//\n"
    L"//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make\n"
    L"//  changes by hand, because they will be lost if the file is regenerated.\n"
    L"// ----------------------------------------------------------------------------\n"
    L"#pragma once\n"
    L"\n"
    L"#pragma CIDLIB_PACK(CIDLIBPACK)\n"
    L"\n"
    L"class %(E) %(c) : public %(B)\n"
    L"{\n"
    L"    public :\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Public, static data\n"
    L"        // --------------------------------------------------------------------\n"
    L"<END>\n";

    const tCIDLib::TCh* const pszClientHeader2 =
    L"\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Public Constructors and Destructor\n"
    L"        // --------------------------------------------------------------------\n"
    L"        %(c)();\n"
    L"        %(c)(const TOrbObjId& ooidSrc, const TString& strNSBinding);\n"
    L"        %(c)(const %(c)&) = delete;\n"
    L"        %(c)(%(c)&&) = delete;\n"
    L"        ~%(c)();\n"
    L"\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Public operators\n"
    L"        // --------------------------------------------------------------------\n"
    L"        %(c)& operator=(const %(c)&) = delete;\n"
    L"        %(c)& operator=(%(c)&&) = delete;\n"
    L"\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Public, inherited methods\n"
    L"        // --------------------------------------------------------------------\n"
    L"        tCIDLib::TVoid SetObjId\n"
    L"        (\n"
    L"            const   TOrbObjId& ooidToSet\n"
    L"            , const TString& strNSBinding\n"
    L"            , const tCIDLib::TBoolean bCheck = kCIDLib::True\n"
    L"        )   override;\n"
    L"\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Public, non-virtual methods\n"
    L"        // --------------------------------------------------------------------\n"
    L"<END>\n";

    const tCIDLib::TCh* const pszClientHeader3 =
    L"    protected :\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Declare our friends\n"
    L"        // --------------------------------------------------------------------\n"
    L"        friend class TFacCIDOrb;\n"
    L"\n"
    L"    private :\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Magic macros\n"
    L"        // --------------------------------------------------------------------\n"
    L"        RTTIDefs(%(c),%(B))\n"
    L"};\n"
    L"\n"
    L"#pragma CIDLIB_POPPACK\n"
    L"\n"
    L"inline tCIDLib::TVoid\n"
    L"%(c)::SetObjId(const  TOrbObjId& ooidToSet\n"
    L"              , const TString& strNSBinding\n"
    L"              , const tCIDLib::TBoolean bCheck)\n"
    L"{\n"
    L"    TParent::SetObjId(ooidToSet, strNSBinding, bCheck);\n"
    L"}\n\n"
    L"<END>\n";


    //
    //  Templates for the client side implementation. We have one that gets us
    //  down to the static data, then one that picks up from there and includes
    //  some standard Ctor stuff and takes us to where we insert the methods.
    //  We close it out manually.
    //
    const tCIDLib::TCh* const pszClientImpl1 =
    L"// ----------------------------------------------------------------------------\n"
    L"//  FILE: %(F)\n"
    L"//  DATE: %(T)\n"
    L"//    ID: %(I)\n"
    L"//\n"
    L"//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make\n"
    L"//  changes by hand, because they will be lost if the file is regenerated.\n"
    L"// ----------------------------------------------------------------------------\n"
    L"\n"
    L"// ----------------------------------------------------------------------------\n"
    L"// Includes\n"
    L"// ----------------------------------------------------------------------------\n"
    L"#include \"%(h)\"\n"
    L"\n"
    L"// ----------------------------------------------------------------------------\n"
    L"// Magic macros\n"
    L"// ----------------------------------------------------------------------------\n"
    L"AdvRTTIDecls(%(c),%(B))\n"
    L"\n"
    L"\n"
    L"// ----------------------------------------------------------------------------\n"
    L"// %(c): Public, static data\n"
    L"// ----------------------------------------------------------------------------\n"
    L"<END>\n";

    const tCIDLib::TCh* const pszClientImpl2 =
    L"\n"
    L"// ----------------------------------------------------------------------------\n"
    L"// %(c): Constructors and Destructor\n"
    L"// ----------------------------------------------------------------------------\n"
    L"%(c)::%(c)()\n"
    L"{\n"
    L"}\n"
    L"\n"
    L"%(c)::\n"
    L"%(c)(const TOrbObjId& ooidSrc, const TString& strNSBinding)\n"
    L"{\n"
    L"    #if CID_DEBUG_ON\n"
    L"    if (!ooidSrc.oidKey().bIsInterfaceId(strInterfaceId))\n"
    L"    {\n"
    L"        facCIDOrb().ThrowErr\n"
    L"        (\n"
    L"            CID_FILE\n"
    L"            , CID_LINE\n"
    L"            , kOrbErrs::errcClient_BadIntfId\n"
    L"            , tCIDLib::ESeverities::Failed\n"
    L"            , tCIDLib::EErrClasses::BadParms\n"
    L"            , ooidSrc.oidKey().mhashInterface()\n"
    L"            , strInterfaceId\n"
    L"        );\n"
    L"    }\n"
    L"    #endif\n"
    L"    SetObjId(ooidSrc, strNSBinding, kCIDLib::False);\n"
    L"}\n"
    L"\n"
    L"%(c)::~%(c)()\n"
    L"{\n"
    L"}\n"
    L"\n"
    L"// ----------------------------------------------------------------------------\n"
    L"// %(c): Public, non-virtual methods\n"
    L"// ----------------------------------------------------------------------------\n"
    L"<END>\n";



    //
    //  The server side header templates. We have one that get us down
    //  to where we insert the static data, then the next gets us to where we
    //  insert the methods, then a third to close it out.
    //
    const tCIDLib::TCh* const pszServerHeader1 =
    L"// ----------------------------------------------------------------------------\n"
    L"//  FILE: %(F)\n"
    L"//  DATE: %(T)\n"
    L"//    ID: %(I)\n"
    L"//\n"
    L"//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make\n"
    L"//  changes by hand, because they will be lost if the file is regenerated.\n"
    L"// ----------------------------------------------------------------------------\n"
    L"#pragma once\n"
    L"\n"
    L"#pragma CIDLIB_PACK(CIDLIBPACK)\n"
    L"\n"
    L"class %(E) %(s) : public %(B)\n"
    L"{\n"
    L"    public :\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Public, static data\n"
    L"        // --------------------------------------------------------------------\n"
    L"<END>\n";

    const tCIDLib::TCh* const pszServerHeader2 =
    L"        // --------------------------------------------------------------------\n"
    L"        // Constructors and destructor\n"
    L"        // --------------------------------------------------------------------\n"
    L"        %(s)(const %(s)&) = delete;\n"
    L"        %(s)(%(s)&&) = delete;\n"
    L"        ~%(s)();\n"
    L"\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Public operators\n"
    L"        // --------------------------------------------------------------------\n"
    L"        %(s)& operator=(const %(s)&) = delete;\n"
    L"        %(s)& operator=(%(s)&&) = delete;\n"
    L"\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Public, pure virtual methods\n"
    L"        // --------------------------------------------------------------------\n"
    L"<END>\n";

    const tCIDLib::TCh* const pszServerHeader3 =
    L"    protected :\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Hidden constructors\n"
    L"        // --------------------------------------------------------------------\n"
    L"        %(s)(%(P));\n"
    L"        %(s)(const TOrbObjId& ooidThis%(N));\n"
    L"\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Protected, inherited methods\n"
    L"        // --------------------------------------------------------------------\n"
    L"        tCIDLib::TVoid Dispatch\n"
    L"        (\n"
    L"            const  TString&      strMethodName\n"
    L"            ,      TOrbCmd&      orbcToDispatch\n"
    L"        )   override;\n"
    L"\n"
    L"    private :\n"
    L"        // --------------------------------------------------------------------\n"
    L"        // Magic macros\n"
    L"        // --------------------------------------------------------------------\n"
    L"        RTTIDefs(%(s),%(B))\n"
    L"};\n"
    L"\n"
    L"#pragma CIDLIB_POPPACK\n\n"
    L"<END>\n";


    //
    //  The server side implementation templates. We have one that get us down
    //  to where we insert the static data, then the next gets us to where we
    //  insert the methods.
    //
    const tCIDLib::TCh* const pszServerImpl1 =
    L"// ----------------------------------------------------------------------------\n"
    L"//  FILE: %(F)\n"
    L"//  DATE: %(T)\n"
    L"//    ID: %(I)\n"
    L"//\n"
    L"//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make\n"
    L"//  changes by hand, because they will be lost if the file is regenerated.\n"
    L"// ----------------------------------------------------------------------------\n"
    L"\n"
    L"// ----------------------------------------------------------------------------\n"
    L"// Includes\n"
    L"// ----------------------------------------------------------------------------\n"
    L"#include \"%(h)\"\n"
    L"\n"
    L"// ----------------------------------------------------------------------------\n"
    L"// Magic macros\n"
    L"// ----------------------------------------------------------------------------\n"
    L"RTTIDecls(%(s),%(B))\n"
    L"\n"
    L"\n"
    L"// ----------------------------------------------------------------------------\n"
    L"// Public, static data\n"
    L"// ----------------------------------------------------------------------------\n"
    L"<END>\n";

    const tCIDLib::TCh* const pszServerImpl2 =
    L"// ----------------------------------------------------------------------------\n"
    L"// %(s): Destructor\n"
    L"// ----------------------------------------------------------------------------\n"
    L"%(s)::~%(s)()\n"
    L"{\n"
    L"}\n"
    L"\n"
    L"// ----------------------------------------------------------------------------\n"
    L"// %(s): Protected Constructors\n"
    L"// ----------------------------------------------------------------------------\n"
    L"%(s)::%(s)(%(P)) :\n"
    L"    %(B)(strInterfaceId, L\"%(c)\" %(n))\n"
    L"{\n"
    L"}\n"
    L"\n"
    L"%(s)::%(s)(const TOrbObjId& ooidThis%(N)) :\n"
    L"    %(B)(ooidThis%(n))\n"
    L"{\n"
    L"}\n"
    L"\n"
    L"// ----------------------------------------------------------------------------\n"
    L"// %(s): Public, non-virtual methods\n"
    L"// ----------------------------------------------------------------------------\n"
    L"tCIDLib::TVoid %(s)::Dispatch(const TString& strMethodName, TOrbCmd& orbcToDispatch)\n"
    L"{\n"
    L"<END>\n";


    //
    //  The header for generated globals (constants and types not part of the
    //  class and generated into their own file) header.
    //
    const tCIDLib::TCh* const pszGlobalsHeader1 =
    L"// ----------------------------------------------------------------------------\n"
    L"//  FILE: %(F)\n"
    L"//  DATE: %(T)\n"
    L"//\n"
    L"//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make\n"
    L"//  changes by hand, because they will be lost if the file is regenerated.\n"
    L"// ----------------------------------------------------------------------------\n"
    L"#pragma once\n"
    L"\n"
    L"#pragma CIDLIB_PACK(CIDLIBPACK)\n"
    L"\n"
    L"<END>\n";

    const tCIDLib::TCh* const pszGlobalsHeader2 =
    L"#pragma CIDLIB_POPPACK\n\n"
    L"<END>\n";

    const tCIDLib::TCh* const pszGlobalsImpl1 =
    L"// ----------------------------------------------------------------------------\n"
    L"//  FILE: %(F)\n"
    L"//  DATE: %(T)\n"
    L"//\n"
    L"//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make\n"
    L"//  changes by hand, because they will be lost if the file is regenerated.\n"
    L"// ----------------------------------------------------------------------------\n"
    L"\n"
    L"#include \"%(h)\"\n\n"
    L"<END>\n";
}




// ---------------------------------------------------------------------------
//   CLASS: TCppGenerator
//  PREFIX: cgen
// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
//  TCppGenerator: Constructors and Destructor
// ---------------------------------------------------------------------------
TCppGenerator::TCppGenerator() :

    m_colMethNameList(23, TStringKeyOps())
    , m_strmHeader(new TUSASCIIConverter)
    , m_strmImpl(new TUSASCIIConverter)
    , m_strmXHeader(1024UL)
{
}

TCppGenerator::~TCppGenerator()
{
}


// ---------------------------------------------------------------------------
//  TCppGenerator: Public, inherited methods
// ---------------------------------------------------------------------------
tCIDLib::TVoid
TCppGenerator::BeginClientIntf( const   TString&            strBaseClass
                                , const TString&            strOutputDir
                                , const TString&            strFacName
                                , const TString&            strOptName
                                , const TString&            strExpKeyword
                                , const tCIDLib::TBoolean   bPrivHeader)
{
    // Set the mode that we are in now;
    m_eMode = tCIDIDL::EOutputs::Client;

    // Store some stuff for later
    m_strFacName = strFacName;
    m_strBaseClass = strBaseClass;
    m_strExpKeyword = strExpKeyword;

    // Make the client class the target class
    m_strTargetClass = m_strClientClass;

    // Set up the header and impl file output streams
    TString strClientHpp(strFacName);
    strClientHpp.Append(L"_");
    strClientHpp.Append(strOptName);
    strClientHpp.Append(L"ClientProxy.hpp");
    TPathStr pathClientFile(strOutputDir);
    pathClientFile.AddLevel(strClientHpp);
    m_strmHeader.Open
    (
        pathClientFile
        , tCIDLib::ECreateActs::CreateAlways
        , tCIDLib::EFilePerms::Default
        , tCIDLib::EFileFlags::SequentialScan
        , tCIDLib::EAccessModes::Excl_Write
    );

    // Pre-build the file and class names, since we'll use them a number of times
    TString strClientCpp(strFacName);
    strClientCpp.Append(L"_");
    strClientCpp.Append(strOptName);
    strClientCpp.Append(L"ClientProxy.cpp");
    TPathStr pathServerFile(strOutputDir);
    pathServerFile.AddLevel(strClientCpp);
    m_strmImpl.Open
    (
        pathServerFile
        , tCIDLib::ECreateActs::CreateAlways
        , tCIDLib::EFilePerms::Default
        , tCIDLib::EFileFlags::SequentialScan
        , tCIDLib::EAccessModes::Excl_Write
    );

    // Write out the template for the first part of the client header
    WriteTemplate
    (
        m_strmHeader
        , CIDIDL_CppGenerator::pszClientHeader1
        , strClientHpp
    );

    // Write out the template for the first part of the client impl
    WriteTemplate
    (
        m_strmImpl
        , CIDIDL_CppGenerator::pszClientImpl1
        , strClientCpp
        , bPrivHeader
    );
}


tCIDLib::TVoid TCppGenerator::BeginCodeGen()
{
}


tCIDLib::TVoid TCppGenerator::BeginConstants()
{
    //
    //  If in global mode, we are creating a namespace that holds the
    //  constants, so put out the opening of that. In client/server mode,
    //  the constants are going inside a class.
    //
    if (m_eMode == tCIDIDL::EOutputs::Global)
    {
        // Open the constants namespace for this file
        m_strmHeader << L"// " << TTextOutStream::RepChars(L'-', 76) << kCIDLib::NewLn
                     << L"// Constants namespace\n"
                     << L"// " << TTextOutStream::RepChars(L'-', 76) << kCIDLib::NewLn
                     << L"namespace k" << m_strFacName << L"\n{\n";
    }
}


tCIDLib::TVoid
TCppGenerator::BeginGlobals(const   TString&            strGlobalsOutputDir
                            , const TString&            strGlobalsFacName
                            , const TString&            strGlobalsOptName
                            , const TString&            strExpKeyword
                            , const tCIDLib::TBoolean   bPrivHeader)
{
    // Set the mode that we are in now;
    m_eMode = tCIDIDL::EOutputs::Global;

    // Store some stuff for later use
    m_strFacName = strGlobalsFacName;
    m_strExpKeyword = strExpKeyword;

    // Create the output files for the globals
    TString strGlobalsHdr(strGlobalsFacName);
    strGlobalsHdr.Append(L"_");
    strGlobalsHdr.Append(strGlobalsOptName);
    strGlobalsHdr.Append(L".hpp");

    TPathStr pathGlobalsHdr(strGlobalsOutputDir);
    pathGlobalsHdr.AddLevel(strGlobalsHdr);

    TString strGlobalsImpl(strGlobalsFacName);
    strGlobalsImpl.Append(L"_");
    strGlobalsImpl.Append(strGlobalsOptName);
    strGlobalsImpl.Append(L".cpp");

    TPathStr pathGlobalsImpl(strGlobalsOutputDir);
    pathGlobalsImpl.AddLevel(strGlobalsImpl);

    // Create the text file output stream
    m_strmHeader.Open
    (
        pathGlobalsHdr
        , tCIDLib::ECreateActs::CreateAlways
        , tCIDLib::EFilePerms::Default
        , tCIDLib::EFileFlags::SequentialScan
        , tCIDLib::EAccessModes::Excl_Write
    );

    m_strmImpl.Open
    (
        pathGlobalsImpl
        , tCIDLib::ECreateActs::CreateAlways
        , tCIDLib::EFilePerms::Default
        , tCIDLib::EFileFlags::SequentialScan
        , tCIDLib::EAccessModes::Excl_Write
    );

    // Output the file headers
    WriteTemplate
    (
        m_strmHeader
        , CIDIDL_CppGenerator::pszGlobalsHeader1
        , strGlobalsHdr
    );

    WriteTemplate
    (
        m_strmImpl
        , CIDIDL_CppGenerator::pszGlobalsImpl1
        , strGlobalsImpl
        , bPrivHeader
    );
}


tCIDLib::TVoid
TCppGenerator::BeginIntf(const  TString&    strInterfaceName
                        , const TString&    strInterfaceId)
{
    // Store away this info, which we'll use later
    m_strInterfaceId = strInterfaceId;
    m_strInterfaceName = strInterfaceName;

    // Build up the client and server class names.
    m_strClientClass = L"T";
    m_strClientClass.Append(m_strInterfaceName, L"ClientProxy");

    m_strServerClass = L"T";
    m_strServerClass.Append(m_strInterfaceName, L"ServerBase");
}


tCIDLib::TVoid TCppGenerator::BeginMethods()
{
    // Reset the method name list, which we use to catch overloads
    m_colMethNameList.RemoveAll();

    if (m_eMode == tCIDIDL::EOutputs::Client)
    {
        WriteTemplate
        (
            m_strmHeader
            , CIDIDL_CppGenerator::pszClientHeader2
            , m_strmHeader.strFileName()
        );

        WriteTemplate
        (
            m_strmImpl
            , CIDIDL_CppGenerator::pszClientImpl2
            , m_strmImpl.strFileName()
        );
    }
     else if (m_eMode == tCIDIDL::EOutputs::Server)
    {
        WriteTemplate
        (
            m_strmImpl
            , CIDIDL_CppGenerator::pszServerImpl2
            , m_strmImpl.strFileName()
        );

        WriteTemplate
        (
            m_strmHeader
            , CIDIDL_CppGenerator::pszServerHeader2
            , m_strmHeader.strFileName()
        );
    }
}


tCIDLib::TVoid
TCppGenerator::BeginServerIntf( const   TString&            strBaseClass
                                , const TString&            strOutputDir
                                , const TString&            strFacName
                                , const TString&            strOptName
                                , const TString&            strExpKeyword
                                , const tCIDIDL::TParmList& colCtorParams
                                , const tCIDLib::TBoolean   bPrivHeader)
{
    // Set the mode that we are in now;
    m_eMode = tCIDIDL::EOutputs::Server;

    // Store the facility name and base class for later use
    m_strFacName = strFacName;
    m_strBaseClass = strBaseClass;
    m_strExpKeyword = strExpKeyword;

    // Make the server class the target class
    m_strTargetClass = m_strServerClass;

    //
    //  Build up the two parameter list strings. Because the server side
    //  supports a set of 'passthrough' parameters, defined in the IDL,
    //  we have two replacement parms in the template text that we replace
    //  with the parameter lists that we build here.
    //
    //  And we need versions with leading commas as well. But if the main
    //  versions are empty, make these empty too.
    //
    m_strNPList.Clear();
    m_strNList.Clear();
    m_strNPListC.Clear();
    m_strNListC.Clear();

    TString strTmp;
    const tCIDLib::TCard4 c4ParmCount = colCtorParams.c4ElemCount();
    for (tCIDLib::TCard4 c4Index = 0; c4Index < c4ParmCount; c4Index++)
    {
        // If not the first parm, then do a comma separator
        if (c4Index)
        {
            m_strNPList.Append(L", ");
            m_strNList.Append(L", ");
        }

        m_strNPList.Append(colCtorParams[c4Index].strName());
        FormatParam(colCtorParams[c4Index], strTmp, kCIDLib::False);
        m_strNList.Append(strTmp);
    }

    if (!m_strNPList.bIsEmpty())
    {
        m_strNPListC = L", ";
        m_strNPListC.Append(m_strNPList);
        m_strNListC = L", ";
        m_strNListC.Append(m_strNList);
    }

    // Set up the output streams
    TString strServerCpp(m_strFacName);
    strServerCpp.Append(L"_");
    strServerCpp.Append(strOptName);
    strServerCpp.Append(L"ServerBase.cpp");
    TPathStr pathImpl(strOutputDir);
    pathImpl.AddLevel(strServerCpp);

    m_strmImpl.Open
    (
        pathImpl
        , tCIDLib::ECreateActs::CreateAlways
        , tCIDLib::EFilePerms::Default
        , tCIDLib::EFileFlags::SequentialScan
        , tCIDLib::EAccessModes::Excl_Write
    );


    TString strServerHpp(strFacName);
    strServerHpp.Append(L"_");
    strServerHpp.Append(strOptName);
    strServerHpp.Append(L"ServerBase.hpp");
    TPathStr pathHeader(strOutputDir);
    pathHeader.AddLevel(strServerHpp);

    m_strmHeader.Open
    (
        pathHeader
        , tCIDLib::ECreateActs::CreateAlways
        , tCIDLib::EFilePerms::Default
        , tCIDLib::EFileFlags::SequentialScan
        , tCIDLib::EAccessModes::Excl_Write
    );

    // Generate the template for the opening part of the file
    WriteTemplate
    (
        m_strmHeader
        , CIDIDL_CppGenerator::pszServerHeader1
        , strServerHpp
    );

    // Generate the template for the opening part of the file
    WriteTemplate
    (
        m_strmImpl
        , CIDIDL_CppGenerator::pszServerImpl1
        , strServerCpp
        , bPrivHeader
    );
}


tCIDLib::TVoid TCppGenerator::BeginTypes()
{
    // If in globals mode, we need to start a namespace for these
    if (m_eMode == tCIDIDL::EOutputs::Global)
    {
        m_strmHeader << L"// " << TTextOutStream::RepChars(L'-', 76) << kCIDLib::NewLn
                     << L"// Types namespace\n"
                     << L"// " << TTextOutStream::RepChars(L'-', 76) << kCIDLib::NewLn
                     << L"namespace t" << m_strFacName << L"\n{\n";
    }
}


tCIDLib::TVoid TCppGenerator::EndCodeGen()
{
}


tCIDLib::TVoid TCppGenerator::EndClientIntf()
{
    // And flush and close the streams
    m_strmHeader.Flush();
    m_strmHeader.Close();
    m_strmImpl.Flush();
    m_strmImpl.Close();
}


tCIDLib::TVoid TCppGenerator::EndConstants()
{
    //
    //  If in global mode, then close out the namespace and put out a couple
    //  new lines. Else just put out a couple new lines in both files.
    //
    if (m_eMode == tCIDIDL::EOutputs::Global)
    {
        m_strmHeader << L"}\n\n";
    }
     else
    {
        m_strmHeader << kCIDLib::DNewLn;
        m_strmImpl << kCIDLib::DNewLn;
    }
}


tCIDLib::TVoid TCppGenerator::EndGlobals()
{
    //
    //  Output the header closing. The class and output type stuff are
    //  ignored in this case, so we pass dummy stuff.
    //
    WriteTemplate
    (
        m_strmHeader
        , CIDIDL_CppGenerator::pszGlobalsHeader2
        , m_strmHeader.strFileName()
    );

    //
    //  Now spit out the extra header stuff we accumulated (the global
    //  streaming methods), before we finish off the header stream.
    //
    m_strmXHeader.Flush();
    m_strmHeader << m_strmXHeader.strData();

    // Flush and close the streams
    m_strmHeader.Flush();
    m_strmHeader.Close();

    m_strmImpl.Flush();
    m_strmImpl.Close();
}


tCIDLib::TVoid TCppGenerator::EndIntf()
{
}


tCIDLib::TVoid TCppGenerator::EndMethods()
{
    if (m_eMode == tCIDIDL::EOutputs::Client)
    {
        WriteTemplate
        (
            m_strmHeader
            , CIDIDL_CppGenerator::pszClientHeader3
            , m_strmHeader.strFileName()
        );
    }
     else if (m_eMode == tCIDIDL::EOutputs::Server)
    {
        WriteTemplate
        (
            m_strmHeader
            , CIDIDL_CppGenerator::pszServerHeader3
            , m_strmHeader.strFileName()
        );

        //
        //  Close off the impl code. We pass the call on to our parent
        //  class (the server side base class, who handles any special
        //  internal methods.
        ///
        m_strmImpl  <<  L"     else\n    {\n"
                    <<  L"         TParent::Dispatch(strMethodName, orbcToDispatch);\n"
                    <<  L"    }\n";

        // Close out the method
        m_strmImpl << L"}\n\n";
    }

    //
    //  Now spit out the extra header stuff we accumulated (the global
    //  streaming methods), before we finish off the header stream.
    //
    m_strmXHeader.Flush();
    m_strmHeader << m_strmXHeader.strData();

    m_strmHeader.Flush();
}


tCIDLib::TVoid TCppGenerator::EndServerIntf()
{

    // And flush and close the streams
    m_strmHeader.Flush();
    m_strmHeader.Close();
    m_strmImpl.Flush();
    m_strmImpl.Close();
}


tCIDLib::TVoid TCppGenerator::EndTypes()
{
    //
    //  If in global mode, then close out the namespace and put out a couple
    //  new lines. Else just put out a couple new lines in both files.
    //
    if (m_eMode == tCIDIDL::EOutputs::Global)
    {
        m_strmHeader << L"}\n\n";
    }
     else
    {
        m_strmHeader << kCIDLib::DNewLn;
        m_strmImpl << kCIDLib::DNewLn;
    }
}


// Generate a single constant
tCIDLib::TVoid
TCppGenerator::GenConstant( const   TString&            strName
                            , const TString&            strType
                            , const TString&            strValue
                            , const TString&            strDocs)
{
    // If any documentation, generate that
    if (!strDocs.bIsEmpty())
        GenDocText(m_strmHeader, strDocs, m_eMode);

    // Translate the IDL type to our local type
    TString strRealType;
    FormatConstType(strType, strRealType);

    if (m_eMode == tCIDIDL::EOutputs::Global)
    {
        if (strRealType == L"TString")
        {
            //
            //  We put the actual intitialization out of line, since
            //  there are a lot of these and they are objects.
            //
            m_strmHeader << L"    " << m_strExpKeyword
                         << L" const extern TString " << strName;

            m_strmImpl   << L"const TString k"
                         << m_strFacName << L"::" << strName
                         << L"(L\"" << strValue << L"\");\n";
        }
         else
        {
            m_strmHeader << L"    constexpr "
                         << strRealType << L" " << strName << L" = ";
            if (strRealType == L"tCIDLib::TBoolean")
                m_strmHeader << L"kCIDLib::";
            m_strmHeader << strValue;
        }
        m_strmHeader << L";\n";
    }
     else
    {
        if (strRealType == L"TString")
        {
            m_strmHeader << L"        static const " << strRealType << L" " << strName;
        }
         else
        {
            m_strmHeader << L"        static constexpr "
                         << strRealType << L" " << strName << L" = ";
            if (strRealType == L"tCIDLib::TBoolean")
                m_strmHeader << L"kCIDLib::";
            m_strmHeader << strValue;
        }
        m_strmHeader << L";\n";
    }

    // If doing client or server, then we have to do the cpp file also
    if ((m_eMode == tCIDIDL::EOutputs::Client)
    ||  (m_eMode == tCIDIDL::EOutputs::Server))
    {
        if (strType == L"TString")
        {
            m_strmImpl << L"const "
                       << strType
                       << L" "
                       << m_strTargetClass << L"::" << strName
                       << L"(L\""
                       << strValue
                       << L"\");\n";
        }
         else if (strRealType == L"tCIDLib::TBoolean")
        {
            m_strmImpl << L"const "
                       << strRealType
                       << L" "
                       << m_strTargetClass << L"::" << strName
                       << L"(kCIDLib::"
                       << strValue
                       << L");\n";
        }
        /*
         else
        {
            m_strmImpl << L"const "
                       << strRealType
                       << L" "
                       << m_strTargetClass << L"::" << strName
                       << L"("
                       << strValue
                       << L");\n";
        }
        */
    }
}


tCIDLib::TVoid
TCppGenerator::GenEnum( const   TString&            strDocs
                        ,       TCGenEnumInfo&      einfoToGen)
{
    // If any documentation, generate that
    if (!strDocs.bIsEmpty())
        GenDocText(m_strmHeader, strDocs, m_eMode);

    //
    //  Set up a little stuff we have to pass to the enum to get it to generate
    //  the output for us.
    //
    tCIDLib::TBoolean bGlobType = kCIDLib::False;
    TString strEnclosing;
    if (m_eMode == tCIDIDL::EOutputs::Client)
    {
        strEnclosing = m_strClientClass;
    }
     else if (m_eMode == tCIDIDL::EOutputs::Server)
    {
        strEnclosing = m_strServerClass;
    }
     else
    {
        strEnclosing = L"t";
        strEnclosing.Append(m_strFacName);
        bGlobType = kCIDLib::True;
    }


    // Ask to generate header content, then implementation content
    einfoToGen.FmtHeader
    (
        bGlobType, strEnclosing, m_strExpKeyword, m_strmHeader, m_strmXHeader
    );
    einfoToGen.FmtImpl(bGlobType, strEnclosing, m_strmImpl);

    m_strmImpl << kCIDLib::NewLn;
    m_strmXHeader << kCIDLib::NewLn;
}


tCIDLib::TVoid
TCppGenerator::GenMethod(const  TString&            strName
                        , const TCGenTypeInfo&      tinfoRet
                        , const tCIDIDL::TParmList& colParams
                        , const tCIDLib::TBoolean   bPollMethod
                        , const tCIDLib::TCard4     c4Timeout
                        , const tCIDLib::TBoolean   bInBaseClass
                        , const tCIDLib::TCard4     c4MethIndex)
{
    TString strTmp;

    // We need to know a couple times below if we have a non-void return
    const tCIDLib::TBoolean bNonVoidRet(tinfoRet.strType() != L"CIDIDL:TVoid");

    // And we'll also need the parameter count a few times
    const tCIDLib::TCard4 c4ParmCount = colParams.c4ElemCount();

    // And also the formatted return type
    TString strRetType;
    FormatType(tinfoRet, strRetType);

    //
    //  We have to deal with the possibility of overridden methods. So, see
    //  if this one is  already used, and provided a numbered version.
    //
    tCIDLib::TCard4 c4Counter  = 1;
    TString         strRealMethName = strName;
    while (m_colMethNameList.bHasElement(strRealMethName))
    {
        strRealMethName = strName;
        strRealMethName.AppendFormatted(c4Counter++);
    }

    // Add the actual method name used to the list
    m_colMethNameList.objAdd(strRealMethName);

    if (m_eMode == tCIDIDL::EOutputs::Client)
    {
        //
        //  First do the client side header. We need to generate the method
        //  signature in this case.
        //

        // Write out the opening part, ret type and method name
        m_strmHeader << TTextOutStream::Spaces(8)
                     << strRetType << L" " << strName;

        //
        //  See how many params we have. If zero, we do a simpler scheme where
        //  we just put out () at the end of the method name.
        //
        if (!c4ParmCount)
        {
            m_strmHeader << L"();\n\n";
        }
         else
        {
            // Wrap around the open paren and do a new line.
            m_strmHeader << kCIDLib::NewLn << TTextOutStream::Spaces(8) << L"(\n";

            // Now loop through the params and output them
            for (tCIDLib::TCard4 c4Index = 0; c4Index < c4ParmCount; c4Index++)
            {
                const TCGenMethodParm& mparmCur = colParams[c4Index];

                //
                //  Write out the parameter. But we have to check for the memory
                //  buffer special cases, and generate an extra magical parameter.
                //
                if (!c4Index)
                    m_strmHeader << TTextOutStream::Spaces(12);
                else
                    m_strmHeader << TTextOutStream::Spaces(12) << L", ";

                if ((mparmCur.tinfoThis().strType() == L"CIDIDL:THeapBuf")
                ||  (mparmCur.tinfoThis().strType() == L"CIDIDL:TMemBuf"))
                {
                    // Get the direction of the parameter
                    const tCIDLib::EParmDirs eDir = mparmCur.eDir();

                    if ((eDir == tCIDLib::EParmDirs::Out)
                    ||  (eDir == tCIDLib::EParmDirs::InOut))
                    {
                        // Should not see TMemBuf here since it is an input only option
                        CIDAssert
                        (
                            !mparmCur.strName().bCompareI(L"CIDIDL:TMemBuf")
                            , L"Should not see TMemBuf for Out or InOut parameters"
                        );

                        m_strmHeader << L"tCIDLib::TCard4& c4BufSz_"
                                     << mparmCur.strName() << kCIDLib::NewLn
                                     << TTextOutStream::Spaces(12) << L", ";
                    }
                     else
                    {
                        m_strmHeader << L"const tCIDLib::TCard4 c4BufSz_"
                                     << mparmCur.strName() << kCIDLib::NewLn
                                     << TTextOutStream::Spaces(12) << L", ";
                    }
                }

                FormatParam(mparmCur, strTmp, kCIDLib::True);
                m_strmHeader << strTmp << kCIDLib::NewLn;
            }

            // Close out the method declaration now
            m_strmHeader  << TTextOutStream::Spaces(8) << L");\n\n";
        }


        //
        //  Now do the implementation file, which requires that we do all
        //  of the parameter flattening, the invocation, and the method
        //  resurrection.
        //

        //
        //  If this is a poll method, then confirm that is has a boolean
        //  return type.
        //
        if (bPollMethod)
        {
            if (tinfoRet.strType() != L"CIDIDL:TBoolean")
                facCIDIDL.GenErr(CID_FILE, CID_LINE, kIDLErrs::errcGen_PollMethRet, strName);
        }

        // Write out the opening part, ret type and method name
        m_strmImpl  << strRetType
                    << L" " << m_strClientClass << L"::" << strName;

        //
        //  See how many params we have. If zero, we do a simpler scheme where
        //  we just put out () at the end of the method name.
        //
        if (!c4ParmCount)
        {
            m_strmImpl << L"()\n{\n";
        }
         else
        {
            m_strmImpl << L"\n(";

            // Now loop through the params and output them
            for (tCIDLib::TCard4 c4Index = 0; c4Index < c4ParmCount; c4Index++)
            {
                const TCGenMethodParm& mparmCur = colParams[c4Index];

                if (c4Index)
                    m_strmImpl << L"\n    , ";
                else
                    m_strmImpl << L"\n    ";

                //
                //  If it's one of the magic memory buffer parms, then we
                //  need to declare the buffer size parm.
                //
                if ((mparmCur.tinfoThis().strType() == L"CIDIDL:THeapBuf")
                ||  (mparmCur.tinfoThis().strType() == L"CIDIDL:TMemBuf"))
                {
                    const tCIDLib::EParmDirs eDir = mparmCur.eDir();
                    if ((eDir == tCIDLib::EParmDirs::Out)
                    ||  (eDir == tCIDLib::EParmDirs::InOut))
                    {
                        // Should not see TMemBuf here since it is an input only option
                        CIDAssert
                        (
                            !mparmCur.strName().bCompareI(L"CIDIDL:TMemBuf")
                            , L"Should not see TMemBuf for Out or InOut parameters"
                        );

                        m_strmImpl  << L"tCIDLib::TCard4& c4BufSz_"
                                    << mparmCur.strName()
                                    << L"\n    , ";
                    }
                     else
                    {
                        m_strmImpl  << L"const tCIDLib::TCard4 c4BufSz_"
                                    << mparmCur.strName()
                                    << L"\n    , ";
                    }
                }

                FormatParam(mparmCur, strTmp, kCIDLib::False);
                m_strmImpl << strTmp;
            }

            m_strmImpl << L")\n{\n";
        }

        //
        //  If there was a return value, then create the local that we
        //  will stream it into.
        //
        if (bNonVoidRet)
        {
            m_strmImpl  << L"    "
                        << strRetType <<  L" retVal;\n";
        }

        //
        //  Get a cmd queue item to use and set the target object on it.
        //  We need to put a try/catch around this, to insure that we give
        //  back the cmd queue item.
        //
        m_strmImpl << L"    TCmdQItem* pcqiToUse = pcqiGetCmdItem(ooidThis().oidKey());\n"
                      L"    TOrbCmd& ocmdToUse = pcqiToUse->ocmdData();\n"
                      L"    try\n"
                      L"    {\n";

        //
        //  Ok, now we have to write the implementation of this method.
        //  Basically, we have to marshall the params, build a command
        //  object, then send it via our parent class.
        //
        MarshallClientParms(strRealMethName, m_strmImpl, colParams);

        //
        //  Call the dispatch method of our parent class. This will send
        //  the data to the server and get the reply. Reset the input
        //  stream so the subsequent code can pull the ret value and parms
        //  out.
        //
        m_strmImpl << L"        Dispatch("
                   << c4Timeout
                   << L", pcqiToUse);\n"
                      L"        ocmdToUse.strmIn().Reset();\n";

        // And unmarshall the return value and out params
        UnMarshallClientParms
        (
            strRealMethName
            , m_strmImpl
            , colParams
            , tinfoRet
            , bPollMethod
        );

        m_strmImpl  << L"        GiveBackCmdItem(pcqiToUse);\n"
                    << L"    }\n"
                    << L"    catch(TError& errToCatch)\n"
                    << L"    {\n"
                    << L"        GiveBackCmdItem(pcqiToUse);\n"
                    << L"        errToCatch.AddStackLevel(CID_FILE, CID_LINE);\n"
                    << L"        throw;\n"
                    << L"    }\n";


        if (bNonVoidRet)
            m_strmImpl << L"    return retVal;\n";

        m_strmImpl << L"}\n\n";
    }
     else if (m_eMode == tCIDIDL::EOutputs::Server)
    {
        //
        //  Do the server header first
        //

        //
        //  If its provided by an inserted base class, then don't generate
        //  it into this header. We'll still generate the handler code
        //  for it in the cpp file, but that code will call the version in
        //  the base class (so the derived class doesn't have to provide
        //  it.)
        //
        if (!bInBaseClass)
        {
            // Write out the opening part, ret type and method name
            m_strmHeader << TTextOutStream::Spaces(8) << L"virtual "
                         << strRetType
                         << L" " << strName;

            //
            //  See how many params we have. If zero, we do a simpler scheme
            /// where we just put out () at the end of the method name.
            //
            if (!c4ParmCount)
            {
                m_strmHeader << L"() = 0;\n\n";
            }
             else
            {
                // Wrap around the open paren and do a new line.
                m_strmHeader << kCIDLib::NewLn << TTextOutStream::Spaces(8) << L"(\n";

                // Now loop through the params and output them
                for (tCIDLib::TCard4 c4Index = 0; c4Index < c4ParmCount; c4Index++)
                {
                    const TCGenMethodParm& mparmCur = colParams[c4Index];

                    //
                    //  Write out the parameter information for this parameter.
                    //  But watch for the special case memory buffer parms,
                    //  which require a magical In TCard parameter.
                    //
                    if (!c4Index)
                        m_strmHeader << TTextOutStream::Spaces(12);
                    else
                        m_strmHeader << TTextOutStream::Spaces(12) << L", ";

                    if ((mparmCur.tinfoThis().strType() == L"CIDIDL:THeapBuf")
                    ||  (mparmCur.tinfoThis().strType() == L"CIDIDL:TMemBuf"))
                    {
                        const tCIDLib::EParmDirs eDir = mparmCur.eDir();

                        if ((eDir == tCIDLib::EParmDirs::Out)
                        ||  (eDir == tCIDLib::EParmDirs::InOut))
                        {
                            // Should not see TMemBuf here since it is an input only option
                            CIDAssert
                            (
                                !mparmCur.strName().bCompareI(L"CIDIDL:TMemBuf")
                                , L"Should not see TMemBuf for Out or InOut parameters"
                            );

                            m_strmHeader << L"tCIDLib::TCard4& c4BufSz_"
                                         << mparmCur.strName() << kCIDLib::NewLn
                                         << TTextOutStream::Spaces(12) << L", ";
                        }
                         else
                        {
                            m_strmHeader << L"const tCIDLib::TCard4 c4BufSz_"
                                        << mparmCur.strName() << kCIDLib::NewLn
                                        << TTextOutStream::Spaces(12) << L", ";
                        }
                    }

                    FormatParam(mparmCur, strTmp, kCIDLib::True);
                    m_strmHeader << strTmp << kCIDLib::NewLn;
                }

                // Close out the method declaration now
                m_strmHeader << TTextOutStream::Spaces(8) << L") = 0;\n\n";
            }
        }

        //
        //  And now do the server side impl file
        //

        if (!c4MethIndex)
            m_strmImpl <<  L"    if ";
        else
            m_strmImpl <<  L"     else if ";

        m_strmImpl  <<  L"(strMethodName == L\""
                    <<  strRealMethName
                    <<  L"\")\n    {\n";

        //
        //  Go through the parameters of this method. For each one, declare
        //  the local. If its an In or InOut type, stream the contents in
        //  from the command's data buffer.
        //
        for (tCIDLib::TCard4 c4Index = 0; c4Index < c4ParmCount; c4Index++)
        {
            const TCGenMethodParm& mparmCur = colParams[c4Index];
            const tCIDLib::EParmDirs eDir = mparmCur.eDir();

            // Format the type
            FormatType(mparmCur.tinfoThis(), strTmp);

            //
            //  Create a local var for the parameter. Do a special case check for the
            //  memory buffer types, since they have to have a magic preceding In TCard4
            //  parm, that indicates the bytes that were streamed (except for input only
            //  moveable ones.)
            //
            //  For output only buffers we set them to zero so that, if the called method
            //  doesn't set it, we won't stream back some random amount of data based on
            //  whatever was on the stack at that location. If it's in/out, then worst
            //  case it will still have the original value we streamed in.
            //
            //  If it's the TKeyedHashSet type we have a special case because we need to
            //  generate some special constructor parameter.
            //
            if ((mparmCur.tinfoThis().strType() == L"CIDIDL:THeapBuf")
            ||  (mparmCur.tinfoThis().strType() == L"CIDIDL:TMemBuf"))
            {
                m_strmImpl  <<  L"        tCIDLib::TCard4 c4BufSz_"
                            <<  mparmCur.strName();

                // If output only, then zero the value, see comments above
                if (eDir == tCIDLib::EParmDirs::Out)
                    m_strmImpl << L" = 0;\n";
                else
                    m_strmImpl << L";\n";

                //
                //  If an input, then stream in its contents, and then declare the
                //  memory buffer with this size parm as a parameter. If not, we still
                //  have to declare the memory buffer, just without a size parm.
                //
                //  We add one to the size just in case it comes in zero, which can
                //  happen if writing an empty file. This insures we never try to
                //  create a zero sized buffer.
                //
                if ((eDir == tCIDLib::EParmDirs::In)
                ||  (eDir == tCIDLib::EParmDirs::InOut))
                {
                    m_strmImpl  << L"        orbcToDispatch.strmIn() >> c4BufSz_"
                                << mparmCur.strName() << L";\n"
                                << L"        " << strTmp
                                << L" "
                                << mparmCur.strName()
                                << L"(c4BufSz_" << mparmCur.strName()
                                << L" + 1);\n        orbcToDispatch.strmIn().c4ReadBuffer("
                                << mparmCur.strName() << L", c4BufSz_"
                                << mparmCur.strName()
                                << L");\n";
                }
                 else
                {
                    // It's an output, so just declare the memory buffer
                    m_strmImpl  << L"        " << strTmp
                                << L" " << mparmCur.strName() <<  L";\n";
                }
            }
             else
            {
                if (mparmCur.tinfoThis().strType() == L"CIDIDL:TKeyedHashSet")
                {
                    m_strmImpl  << L"        "
                                << strTmp
                                << L" "
                                << mparmCur.strName()
                                << kCIDLib::chOpenParen
                                << mparmCur.tinfoThis().strModulus()
                                << L", "
                                << mparmCur.tinfoThis().strKeyOps()
                                << L"(), &"
                                << mparmCur.tinfoThis().strAuxType()
                                << L"::"
                                << mparmCur.tinfoThis().strKeyExtract()
                                << L");\n";
                }
                 else
                {
                    // Just the usual thing, so declare the parm
                    m_strmImpl  << L"        "
                                << strTmp
                                << L" "
                                << mparmCur.strName()
                                << L";\n";
                }

                // And stream in it's contents if an input parm
                if ((eDir == tCIDLib::EParmDirs::In)
                ||  (eDir == tCIDLib::EParmDirs::InOut))
                {
                    m_strmImpl  << L"        orbcToDispatch.strmIn() >> "
                                << mparmCur.strName()
                                << L";\n";
                }
            }
        }

        //
        //  If there is a return value, then create a local and assign the
        //  call to it.
        //
        if (bNonVoidRet)
        {
            m_strmImpl  << L"        "
                        << strRetType
                        << L" retVal = ";
        }
         else
        {
            m_strmImpl  << L"        ";
        }

        m_strmImpl <<  strName << L"\n        (\n";

        //
        //  Go back through the parameters, and reference each of them
        //  in the call.
        //
        for (tCIDLib::TCard4 c4Index = 0; c4Index < c4ParmCount; c4Index++)
        {
            const TCGenMethodParm& mparmCur = colParams[c4Index];

            if (c4Index)
                m_strmImpl << L"          , ";
            else
                m_strmImpl << L"            ";

            //
            //  If this is one of the magic memory buffer parms, then we
            //  have to pass along the magic buffer size parm.
            //
            if ((mparmCur.tinfoThis().strType() == L"CIDIDL:THeapBuf")
            ||  (mparmCur.tinfoThis().strType() == L"CIDIDL:TMemBuf"))
            {
                m_strmImpl  << L"c4BufSz_"
                            << mparmCur.strName() << kCIDLib::NewLn
                            << L"          , ";
            }

            if (mparmCur.bMoveable())
                m_strmImpl << L"tCIDLib::ForceMove(";
            m_strmImpl << mparmCur.strName();
            if (mparmCur.bMoveable())
                m_strmImpl << L")";
            m_strmImpl << kCIDLib::NewLn;
        }

        // Close off the call
        m_strmImpl <<  L"        );\n";

        // Reset the output stream so we can stream return values to it
        m_strmImpl << L"        orbcToDispatch.strmOut().Reset();\n";

        // If there is a return value, then stream it
        if (bNonVoidRet)
            m_strmImpl << L"        orbcToDispatch.strmOut() << retVal;\n";

        //
        //  Now, for all of the output parameters, we have to stream them
        //  back into the command object's buffer. But, if this is a
        //  poll method, and the return was false, then don't do it.
        //
        TString strIndent = L"        ";
        if (bPollMethod)
        {
            m_strmImpl << L"        if (retVal)\n        {\n";
            strIndent.Append(L"    ");
        }

        for (tCIDLib::TCard4 c4Index = 0; c4Index < c4ParmCount; c4Index++)
        {
            const TCGenMethodParm& mparmCur = colParams[c4Index];
            const tCIDLib::EParmDirs eDir = mparmCur.eDir();
            if (eDir == tCIDLib::EParmDirs::In)
                continue;

            //
            //  If it's one of the magic memory buffer types, then we have to stream
            //  back out the data bytes parm, and that many bytes. Else we do the
            //  normal thing.
            //
            if ((mparmCur.tinfoThis().strType() == L"CIDIDL:THeapBuf")
            ||  (mparmCur.tinfoThis().strType() == L"CIDIDL:TMemBuf"))
            {
                m_strmImpl  << strIndent << L"orbcToDispatch.strmOut() << "
                            << L"c4BufSz_" << mparmCur.strName()
                            << L";\n"
                            << strIndent << L"orbcToDispatch.strmOut().c4WriteBuffer("
                            << mparmCur.strName() << L", c4BufSz_"
                            << mparmCur.strName() << L");\n";
            }
             else
            {
                m_strmImpl  <<  strIndent << L"orbcToDispatch.strmOut() << "
                            <<  mparmCur.strName()
                            <<  L";\n";
            }
        }

        if (bPollMethod)
            m_strmImpl << L"        }\n";

        // Close off this one now and do a new line
        m_strmImpl <<  L"    }\n";
    }
}


// ---------------------------------------------------------------------------
//  TCppGenerator: Public, inherited methods
// ---------------------------------------------------------------------------
tCIDLib::TVoid
TCppGenerator::FormatConstType( const   TString&    strRawType
                                ,       TString&    strToFill) const
{
    // According to the type, we do different things
    strToFill = L"tCIDLib::";
    if (strRawType == L"TBoolean")
    {
        strToFill.Append(L"TBoolean");
    }
     else if (strRawType == L"TInt1")
    {
        strToFill.Append(strRawType);
    }
     else if (strRawType == L"TInt2")
    {
        strToFill.Append(strRawType);
    }
     else if (strRawType == L"TInt4")
    {
        strToFill.Append(strRawType);
    }
     else if (strRawType == L"TInt8")
    {
        strToFill.Append(strRawType);
    }
     else if (strRawType == L"TCard1")
    {
        strToFill.Append(strRawType);
    }
     else if (strRawType == L"TCard2")
    {
        strToFill.Append(strRawType);
    }
     else if (strRawType == L"TCard4")
    {
        strToFill.Append(strRawType);
    }
     else if (strRawType == L"TCh")
    {
        strToFill.Append(strRawType);
    }
     else if (strRawType == L"TCard8")
    {
        strToFill.Append(strRawType);
    }
     else if (strRawType == L"TFloat8")
    {
        strToFill.Append(strRawType);
    }
     else if (strRawType == L"TString")
    {
        strToFill = strRawType;
    }
     else
    {
        facCIDIDL.GenErr
        (
            CID_FILE
            , CID_LINE
            , kIDLErrs::errcGen_UnknownType
            , strRawType
        );
    }
}


tCIDLib::TVoid
TCppGenerator::FormatParam( const   TCGenMethodParm&    mparmFmt
                            ,       TString&            strToFill
                            , const tCIDLib::TBoolean   bHeader)
{
    //
    //  If an input parm it's const, as long as it's not not a moveable parm
    //  on the server.
    //
    strToFill.Clear();
    if (mparmFmt.eDir() == tCIDLib::EParmDirs::In)
    {
        // Hard to do this logic so do the negative and negate
        if (!((m_eMode == tCIDIDL::EOutputs::Server) && mparmFmt.bMoveable()))
            strToFill = L"const ";
    }

    // And format the type part to a temp, then append that to the output string
    TString strTmp;
    FormatType(mparmFmt.tinfoThis(), strTmp);
    strToFill.Append(strTmp);

    //
    //  If the direction is Out or InOut, or the type is collection, object, or
    //  string, or one of the memory buffer types, then we need to make it a
    //  reference.
    //
    const TString& strRawType = mparmFmt.tinfoThis().strType();

    if ((mparmFmt.eDir() == tCIDLib::EParmDirs::Out)
    ||  (mparmFmt.eDir() == tCIDLib::EParmDirs::InOut)
    ||  (strRawType == L"CIDIDL:Object")
    ||  (strRawType == L"CIDIDL:TBag")
    ||  (strRawType == L"CIDIDL:TVector")
    ||  (strRawType == L"CIDIDL:THeapBuf")
    ||  (strRawType == L"CIDIDL:TMemBuf")
    ||  (strRawType == L"CIDIDL:TFundArray")
    ||  (strRawType == L"CIDIDL:TFundVector")
    ||  (strRawType == L"CIDIDL:TString"))
    {
        if ((m_eMode == tCIDIDL::EOutputs::Server) && mparmFmt.bMoveable())
            strToFill.Append(L"&& ");
        else
            strToFill.Append(L"& ");
    }
     else
    {
        strToFill.Append(L" ");
    }

    // Now we have to do the parameter name
    strToFill.Append(mparmFmt.strName());

    // If in the header and there's a default value, generate that
    if (bHeader && !mparmFmt.strDefVal().bIsEmpty())
    {
        strToFill.Append(L" = ");
        strToFill.Append(mparmFmt.strDefVal());
    }
}


tCIDLib::TVoid
TCppGenerator::FormatType(  const   TCGenTypeInfo&  tinfoFmt
                            ,       TString&        strToFill) const
{
    const TString& strRawType = tinfoFmt.strType();

    // According to the type, we do different things
    if (strRawType == L"CIDIDL:TBoolean")
    {
        strToFill = L"tCIDLib::TBoolean";
    }
     else if (strRawType == L"CIDIDL:TInt4")
    {
         strToFill = L"tCIDLib::TInt4";
    }
     else if (strRawType == L"CIDIDL:TInt8")
    {
        strToFill = L"tCIDLib::TInt8";
    }
     else if (strRawType == L"CIDIDL:TCard4")
    {
        strToFill = L"tCIDLib::TCard4";
    }
     else if (strRawType == L"CIDIDL:TCh")
    {
        strToFill = L"tCIDLib::TCh";
    }
     else if (strRawType == L"CIDIDL:TCard8")
    {
        strToFill = L"tCIDLib::TCard8";
    }
     else if (strRawType == L"CIDIDL:TFloat8")
    {
        strToFill = L"tCIDLib::TFloat8";
    }
     else if (strRawType == L"CIDIDL:TString")
    {
        strToFill = L"TString";
    }
     else if (strRawType == L"CIDIDL:THeapBuf")
    {
        strToFill = L"THeapBuf";
    }
     else if (strRawType == L"CIDIDL:TMemBuf")
    {
        //
        //  On the server side we have to use a concrete class to read in the data
        //  and pass it in, so we generate a heap buffer parm on the server side.
        //  This also helps with move semantics.
        //
        if (m_eMode == tCIDIDL::EOutputs::Client)
            strToFill = L"TMemBuf";
        else
            strToFill = L"THeapBuf";
    }
     else if (strRawType == L"CIDIDL:Object")
    {
        // The aux type is the actual type for us
        strToFill = tinfoFmt.strAuxType();
    }
     else if (strRawType == L"CIDIDL:Enumerated")
    {
        // The aux type is the actual type for us
        const TString& strAux = tinfoFmt.strAuxType();

        // If it starts with ?:: then replace the question
        if (strAux.bStartsWith(L"?::"))
        {
            if (m_eMode == tCIDIDL::EOutputs::Client)
            {
                strToFill = m_strClientClass;
            }
             else if (m_eMode == tCIDIDL::EOutputs::Server)
            {
                strToFill = m_strServerClass;
            }
             else
            {
                strToFill = L"t";
                strToFill.Append(m_strFacName);
            }
            strToFill.AppendSubStr(strAux, 1);
        }
         else
        {
            strToFill = strAux;
        }
    }
     else if (strRawType == L"CIDIDL:TBag")
    {
        strToFill = L"TBag<";
        strToFill.Append(tinfoFmt.strAuxType());
        strToFill.Append(L">");
    }
     else if (strRawType == L"CIDIDL:THashSet")
    {
        strToFill = L"THashSet<";
        strToFill.Append(tinfoFmt.strAuxType());
        strToFill.Append(L", ");
        strToFill.Append(tinfoFmt.strKeyOps());
        strToFill.Append(L">");
    }
     else if (strRawType == L"CIDIDL:TKeyedHashSet")
    {
        strToFill = L"TKeyedHashSet<";
        strToFill.Append(tinfoFmt.strAuxType());
        strToFill.Append(L", ");
        strToFill.Append(tinfoFmt.strKeyType());
        strToFill.Append(L", ");
        strToFill.Append(tinfoFmt.strKeyOps());
        strToFill.Append(L">");
    }
     else if (strRawType == L"CIDIDL:TVector")
    {
        strToFill = L"TVector<";

        // The aux type is the actual type for us
        const TString& strAux = tinfoFmt.strAuxType();

        // If it starts with ?:: then replace the question
        if (strAux.bStartsWith(L"?::"))
        {
            if (m_eMode == tCIDIDL::EOutputs::Client)
            {
                strToFill.Append(m_strClientClass);
            }
             else if (m_eMode == tCIDIDL::EOutputs::Server)
            {
                strToFill.Append(m_strServerClass);
            }
             else
            {
                strToFill.Append(L"t");
                strToFill.Append(m_strFacName);
            }
            strToFill.AppendSubStr(strAux, 1);
        }
         else
        {
            strToFill.Append(strAux);
        }

        strToFill.Append(L">");
    }
     else if (strRawType == L"CIDIDL:TFundArray")
    {
        strToFill = L"TFundArray<";

        // The aux type is the actual type for us
        const TString& strAux = tinfoFmt.strAuxType();

        // If it starts with ?:: then replace the question
        if (strAux.bStartsWith(L"?::"))
        {
            if (m_eMode == tCIDIDL::EOutputs::Client)
            {
                strToFill.Append(m_strClientClass);
            }
             else if (m_eMode == tCIDIDL::EOutputs::Server)
            {
                strToFill.Append(m_strServerClass);
            }
             else
            {
                strToFill.Append(L"t");
                strToFill.Append(m_strFacName);
            }
            strToFill.AppendSubStr(strAux, 1);
        }
         else
        {
            strToFill.Append(strAux);
        }
        strToFill.Append(L">");
    }
     else if (strRawType == L"CIDIDL:TFundVector")
    {
        strToFill = L"TFundVector<";
        strToFill.Append(tinfoFmt.strAuxType());
        strToFill.Append(L">");
    }
     else if (strRawType == L"CIDIDL:TVoid")
    {
        strToFill = L"tCIDLib::TVoid";
    }
     else
    {
        facCIDIDL.GenErr
        (
            CID_FILE
            , CID_LINE
            , kIDLErrs::errcGen_UnknownType
            , strRawType
        );
    }
}


tCIDLib::TVoid
TCppGenerator::MarshallClientParms( const   TString&            strMethodName
                                    ,       TTextFileOutStream& strmOut
                                    , const tCIDIDL::TParmList& colParams)
{
    m_strmImpl  << L"        ocmdToUse.strmOut() << TString(L\""
                << strMethodName << L"\");\n";

    //
    //  Loop through the parameters, and output the code to stream each of them
    //  to the stream.
    //
    const tCIDLib::TCard4 c4ParmCount = colParams.c4ElemCount();
    for (tCIDLib::TCard4 c4Index = 0; c4Index < c4ParmCount; c4Index++)
    {
        const TCGenMethodParm& mparmCur = colParams[c4Index];

        // Get the direction of the parameter
        const tCIDLib::EParmDirs eDir = mparmCur.eDir();

        // We only marshall them if they are out or in/out
        if ((eDir == tCIDLib::EParmDirs::In) || (eDir == tCIDLib::EParmDirs::InOut))
        {
            //
            //  Check for the special cases of a memory buffer. If we have
            //  one of those, then we do a special case streaming call, and
            //  we generate a magic In TCard4 parm before this parm, which
            //  takes the bytes to stream.
            //
            const TString& strParmType = mparmCur.tinfoThis().strType();
            const TString& strParmName = mparmCur.strName();
            if ((strParmType == L"CIDIDL:THeapBuf")
            ||  (strParmType == L"CIDIDL:TMemBuf"))
            {
                m_strmImpl  << L"        ocmdToUse.strmOut() << "
                            << L"c4BufSz_" << strParmName << L";\n"
                            << L"        ocmdToUse.strmOut().c4WriteBuffer("
                            << strParmName << L", c4BufSz_" << strParmName << L");\n";
            }
             else
            {
                m_strmImpl  << L"        ocmdToUse.strmOut() << "
                            << strParmName << L";\n";
            }
        }
    }
}


tCIDLib::TVoid
TCppGenerator::UnMarshallClientParms(const  TString&            strMethodName
                                    ,       TTextFileOutStream& strmOut
                                    , const tCIDIDL::TParmList& colParams
                                    , const TCGenTypeInfo&      tinfoRet
                                    , const tCIDLib::TBoolean   bPollMethod)
{
    //
    //  If there was a return value, then it is the first thing in the
    //  buffer, so we need to get that out first.
    //
    if (tinfoRet.strType() != L"CIDIDL:TVoid")
        m_strmImpl <<  L"        ocmdToUse.strmIn() >> retVal;\n";

    //
    //  If this is a poll method, and the return is false, then we don't
    //  unmarshall any parameters, because they weren't streamed back.
    //
    TString strIndent("        ");
    if (bPollMethod)
    {
        m_strmImpl <<  L"        if (retVal)\n        {\n";
        strIndent.Append(L"    ");
    }

    const tCIDLib::TCard4 c4ParmCount = colParams.c4ElemCount();
    for (tCIDLib::TCard4 c4Index = 0; c4Index < c4ParmCount; c4Index++)
    {
        const TCGenMethodParm& mparmCur = colParams[c4Index];

        // Get the direction of the parameter
        const tCIDLib::EParmDirs eDir = mparmCur.eDir();

        // We only marshall them if they are out or in/out
        if ((eDir == tCIDLib::EParmDirs::Out) || (eDir == tCIDLib::EParmDirs::InOut))
        {
            //
            //  If it's one of the magic memory buffer parms, then we need
            //  unmarshal the magic data bytes parm first. Note that TMemBuf is not
            //  not valid here, so we shouldn't see it.
            //
            const TString& strParmType = mparmCur.tinfoThis().strType();
            const TString& strParmName = mparmCur.strName();
            if (strParmType == L"CIDIDL:THeapBuf")
            {
                m_strmImpl  << strIndent << L"ocmdToUse.strmIn() >> c4BufSz_"
                            << strParmName
                            << L";\n"
                            << strIndent << L"ocmdToUse.strmIn().c4ReadBuffer("
                            << strParmName
                            << L", c4BufSz_" << strParmName << L");\n";
            }
             else if (strParmType == L"CIDIDL:TMemBuf")
            {
                facCIDIDL.GenErr
                (
                    CID_FILE
                    , CID_LINE
                    , kIDLErrs::errcInp_InOnly
                    , strParmType
                );
            }
             else
            {
                m_strmImpl  << strIndent << L"ocmdToUse.strmIn() >> "
                            << strParmName
                            << L";\n";
            }
        }
    }

    if (bPollMethod)
        m_strmImpl << L"        }\n";
}


//
//  This method writes out template text that is fixed except for a set of
//  replacement parameters. This guy will replace those tokens in the passed
//  source text and write it out.
//
tCIDLib::TVoid
TCppGenerator::WriteTemplate(       TTextFileOutStream& strmOut
                            , const tCIDLib::TCh* const pszData
                            , const TString&            strFilePath
                            , const tCIDLib::TBoolean   bPrivHeader)
{
    // Create a stream of the input
    TString strData(pszData);
    TTextStringInStream strmTempl(tCIDLib::ForceMove(strData));

    //
    //  Loop through the input of the template, one line at a time, and replace
    //  each token when the appropriate content.
    //
    TString strInput;
    TString strTokList;
    while (kCIDLib::True)
    {
        // Get the next line
        strmTempl.c4GetLine(strInput);

        // If its the terminator, break out
        if (strInput == L"<END>")
            break;

        // Search for any of the tokens we support and replace them
        const tCIDLib::TBoolean bFound = strInput.bFindTokenList(strTokList);
        if (bFound)
        {
            const tCIDLib::TCard4 c4TokCnt = strTokList.c4Length();
            for (tCIDLib::TCard4 c4Index = 0; c4Index < c4TokCnt; c4Index++)
            {
                const tCIDLib::TCh chCur = strTokList[c4Index];

                switch(chCur)
                {
                    case L'C' :
                        strInput.eReplaceToken(m_strTargetClass, L'C');
                        break;

                    case L's' :
                        strInput.eReplaceToken(m_strServerClass, L's');
                        break;

                    case L'c' :
                        strInput.eReplaceToken(m_strClientClass, L'c');
                        break;

                    case L'I' :
                        strInput.eReplaceToken(m_strInterfaceId, L'I');
                        break;

                    case L'T' :
                    {
                        TTime tmCurrent(tCIDLib::ESpecialTimes::CurrentTime);
                        tmCurrent.strDefaultFormat(TTime::strCTime());
                        TString strTmp(tmCurrent);
                        strInput.eReplaceToken(strTmp, L'T');
                        break;
                    }

                    case L'F' :
                    {
                        TPathStr pathTmp(strFilePath);
                        pathTmp.bRemovePath();
                        strInput.eReplaceToken(pathTmp, L'F');
                        break;
                    }

                    case L'f' :
                        strInput.eReplaceToken(m_strFacName, L'f');
                        break;

                    case L'E' :
                        strInput.eReplaceToken(m_strExpKeyword, L'E');
                        break;

                    case L'B' :
                        strInput.eReplaceToken(m_strBaseClass, L'B');
                        break;

                    case L'h' :
                    {
                        TPathStr pathTmp(m_strFacName);
                        if (bPrivHeader)
                            pathTmp.Append(L'_');
                        pathTmp.AppendExt(L"hpp");
                        strInput.eReplaceToken(pathTmp, L'h');
                        break;
                    }

                    case L'N' :
                        strInput.eReplaceToken(m_strNPListC, L'N');
                        break;

                    case L'n' :
                        strInput.eReplaceToken(m_strNListC, L'n');
                        break;

                    case L'P' :
                        strInput.eReplaceToken(m_strNPList, L'P');
                        break;

                    case L'p' :
                        strInput.eReplaceToken(m_strNList, L'p');
                        break;

                    default :
                        // Not one we care about, ignore it
                        break;
                };
            }
        }

        // And now write the formatted string
        strmOut << strInput << kCIDLib::NewLn;
    }
}



