// ----------------------------------------------------------------------------
//  FILE: CIDPNG_Shared.hpp
//  DATE: Sat, May 01 11:54:19 2021 -0400
//
//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make
//  changes by hand, because they will be lost if the file is regenerated.
// ----------------------------------------------------------------------------
#pragma once

#pragma CIDLIB_PACK(CIDLIBPACK)

// ----------------------------------------------------------------------------
// Types namespace
// ----------------------------------------------------------------------------
namespace tCIDPNG
{
    
    // ------------------------------------------------------------------------
    //  Our representation of the chunk types. We make it bitmapped so that
    //  we can also use it to keep up with whether we've seen specific
    //  chunks.
    //                  
    // ------------------------------------------------------------------------
    enum class EChunks : tCIDLib::TCard4
    {
        Header = 0x00000001
        , Palette = 0x00000002
        , Trans = 0x00000004
        , Data = 0x00000008
        , End = 0x00000010
        , Gamma = 0x00100000
        , BgnClr = 0x00200000
        , TransClr = 0x10000000
        , Count = 8
        , None = 0
        , AllBits = 0x1030001F
    };
    [[nodiscard]]  tCIDLib::TBoolean bIsValidEnum(const EChunks eVal);

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tCIDPNG::EChunks eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tCIDPNG::EChunks& eToFill)
    {
        eToFill = tCIDPNG::EChunks(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    [[nodiscard]] constexpr tCIDPNG::EChunks operator|(const tCIDPNG::EChunks eLHS, const tCIDPNG::EChunks eRHS)
    {    
        return tCIDPNG::EChunks(tCIDLib::TEnumMaskType(eLHS) | tCIDLib::TEnumMaskType(eRHS));
    }
    constexpr tCIDPNG::EChunks& operator|=(tCIDPNG::EChunks& eLHS, const tCIDPNG::EChunks eRHS)
    {    
        eLHS = tCIDPNG::EChunks(tCIDLib::TEnumMaskType(eLHS) | tCIDLib::TEnumMaskType(eRHS));
        return eLHS;
    }
    [[nodiscard]] constexpr tCIDPNG::EChunks operator&(const tCIDPNG::EChunks eLHS, const tCIDPNG::EChunks eRHS)
    {    
        return tCIDPNG::EChunks(tCIDLib::TEnumMaskType(eLHS) & tCIDLib::TEnumMaskType(eRHS));
    }
    constexpr tCIDPNG::EChunks& operator&=(tCIDPNG::EChunks& eLHS, const tCIDPNG::EChunks eRHS)
    {    
        eLHS = tCIDPNG::EChunks(tCIDLib::TEnumMaskType(eLHS) & tCIDLib::TEnumMaskType(eRHS));
        return eLHS;
    }
    
    // ------------------------------------------------------------------------
    //  The supported compression schemes
    //                  
    // ------------------------------------------------------------------------
    enum class ECompTypes
    {
        Deflate
        , Count
        , Min = Deflate
        , Max = Deflate
    };
    [[nodiscard]]  tCIDLib::TBoolean bIsValidEnum(const ECompTypes eVal);

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tCIDPNG::ECompTypes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tCIDPNG::ECompTypes& eToFill)
    {
        eToFill = tCIDPNG::ECompTypes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  The supported interlacing schemes
    //                  
    // ------------------------------------------------------------------------
    enum class EInterlaces
    {
        None
        , Adam7
        , Count
        , Min = None
        , Max = Adam7
    };
    [[nodiscard]]  tCIDLib::TBoolean bIsValidEnum(const EInterlaces eVal);

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tCIDPNG::EInterlaces eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tCIDPNG::EInterlaces& eToFill)
    {
        eToFill = tCIDPNG::EInterlaces(strmSrc.c4ReadEnum());
        return strmSrc;
    }
}

#pragma CIDLIB_POPPACK

 tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCIDPNG::EChunks* const aeList, const tCIDLib::TCard4 c4Count);
 tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCIDPNG::EChunks* const aeList, const tCIDLib::TCard4 c4Count);

 tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCIDPNG::ECompTypes* const aeList, const tCIDLib::TCard4 c4Count);
 tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCIDPNG::ECompTypes* const aeList, const tCIDLib::TCard4 c4Count);

 tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCIDPNG::EInterlaces* const aeList, const tCIDLib::TCard4 c4Count);
 tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCIDPNG::EInterlaces* const aeList, const tCIDLib::TCard4 c4Count);

