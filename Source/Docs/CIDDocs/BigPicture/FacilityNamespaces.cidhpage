<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE HelpPage PUBLIC "urn:charmedquark.com:CIDLib-Documentation.DTD" "CIDLibDocs.DTD">

<HelpPage>
    <Title>Facility Namespaces</Title>

    <HelpText>

        <P>In CIDLib the classes themselves are not inside a namespace. That may change moving forward, but currently that is not the case. Only enumerations and other types, constants, and various helper functions that would otherwise end up being global are in namespaces. This is of course considerably different from the standard C++ libraries. But, because of the much more monolithic nature of CIDLib in comparison, it's not as nearly as big an issue as it might otherwise be, and it substantially reduces verbosity.</P>

        <P>For the stuff that <Italic>is</Italic> in namespaces, each facility has a set of standard namespaces that it creates, in order to have a consistent scheme for exposing these things. Each facility creates two namespaces, and may get one or two others generated by the build system, as such assuming a facility name of Magnum:</P>

        <List Type="Unordered">
            <LItem Ref="tMagnum">The public namespace for types</LItem>
            <LItem Ref="kMagnum">The public namespace for constants</LItem>
            <LItem Ref="kXXXXErrs">If you have errors defined these are the error ids (and the loadable text ids for them)</LItem>
            <LItem Ref="kXXXXMsgs">If you have messages defined these are the message ids (and the loadable text ids for them)</LItem>
        </List>

        <P>So, for instance, the CIDSock facility has tCIDSock and kCIDSock namespaces to hold any non-class types and constants, respectively.</P>

        <P>The public types/constants namespaces are generally created in the main header (Magnum.hpp in our case) though if there are a lot of types or constants they can be put into Magnum_Types.hpp and Magnum_Constants.hpp files just to avoid making the main header unreadable. Typically though they are in the main header. They are re-opened as needed to deal with header inclusion order issues.</P>

        <P>The names of the error and msg namespaces aren't fixed. You can define them in the message text file. In the above example kMagnumErrs and kMagnumMsgs would have been the ideal choices. But, sometimes the facility name might be kind of log and it would lead to overly long ids (since the error/message ids can be kind of long also.) So sometimes the facility will shorten it for the sake of brevity. For instance, CIDSock uses kSockErrs and kSockMsgs, instead of kCIDSockErrs and kCIDSockMsgs. If you don't explicitly set them, they will get the full facility name.</P>

        <P>Obviously this could be abused, and perhaps it would have been better to just have just stuck to the straight and narrow and forced the use of full length names. But as it stands now that's not the case.</P>

        <Note>If you use the IDL compiler to generate constants or types, they will go into the public types and constants namespaces because the IDL compiler automatically generates them that way. Also, if you have loadable UI resources, they also go into the main public namespace automatically.</Note>

        <SecTitle>Namespace vs. Class Based</SecTitle>

        <P>If a constant or type is purely related to a single class, and is not in any way general purpose, it can be defined in the class that uses it. Though, on the whole, that's not done unless it's some private detail. Otherwise, it is put into one of the above standard facility namespaces. Typically this makes for considerably less verbosity as well, since these standard namespaces are often a good bit shorter than class names. And it's sort of nice to have a single go-to to look for such things in any given facility.</P>

        <P>The ability these days to declare inline constants in classes makes it more reasonable to declare them there where that is appropriate.</P>

        <SecTitle>Internal Namespaces</SecTitle>

        <P>The above namespaces are for public facility types and constants. Facilities can also have internal headers. These are defined in the main internal header (Magnum_.hpp in our case) which is seen by all internal implementation files. These are named the same as the private ones but with a trailing underline, i.e.:</P>

        <List Type="Unordered">
            <LItem Ref="tMagnum_">The internal namespace for types</LItem>
            <LItem Ref="kMagnum_">The internal namespace for constants</LItem>
        </List>

        <SecTitle>Exceptions to the Rule</SecTitle>

        <P>The primary exception to this is the use of a namespace to expose what would otherwise be just a class of nothing but static members. For instance the TEnvironment or TSysInfo namespaces in the CIDLib facility. This avoids any possibility of such classes being instantiated.</P>

    </HelpText>

</HelpPage>
