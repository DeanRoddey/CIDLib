<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE HelpPage PUBLIC "urn:charmedquark.com:CIDLib-Documentation.DTD" "CIDLibDocs.DTD">

<HelpPage>
    <Title>Logging and Exceptions</Title>

    <HelpText>
        <P>CIDLib definitely uses exceptions, though it takes the (sane in my opinion) approach that they are only to be used for failures, not just as a convenient stack unwinding mechanism. Exceptions make general purpose code vastly more straightforward, since most general purpose code doesn't care what went wrong. It just wants to clean up and pass the error on to higher level code that understands the context of the failure.</P>

        <P>CIDLib provides lots of mechanisms for making sure locally scoped resources are cleaned up, released, etc... See Janitors to the left. So most code doesn't need to even explicitly know if an exception occurred. If it happens, things get undone, released, whatever, and the exception propagates onwards and upwards.</P>

        <P>Logging and exceptions are very closely related in CIDLib. CIDLib has a single class that it uses both as thrown exceptions and as the type of objects that the logging system supports. In actual fact they are the same class. TException is the class that is thrown, and there is just an alias that maps the type TLogEvent to the same TException class.</P>

        <P>The alias just allows for more self-describing code. So you could throw a TLogEvent object and log a TException objects if you wanted to, since they are the same thing.</P>

        <SubSecTitle>A Single Exception</SubSecTitle>

        <P>CIDLib is quite different from some other C++ (or C# and some other) libraries slash frameworks, in that it does use a single exception class instead of a whole family of classes. In my opinion this is the most sane approach. In particular it avoids the issues of dealing with any common cleanup if you need to deal with multiple types of exceptions.</P>

        <P>And it just makes dealing with exceptions easier in general since you only have to understand a single exception class that always works the same and has the same information available. And that also of course allows for more automatic use of exception information since it's always the same.</P>

        <SubSecTitle>Indirect Creation</SubSecTitle>

        <P>Also, somewhat different from probably most other systems, is that you never directly create these objects. Instead, you call a method on a facility object (see CIDLib Facilities to the left) to either throw an exception or log a message. The facility object will setup the message or exception and log or throw it it for you.</P>

        <P>There are a number of reasons for this. A key one is that you are always throwing an error or logging a message defined by some facility, which means it has defined loadable text for them. That loadable text often has replacement tokens in it that need to be replaced with runtime information. If you had to do all of this manually, it would get very annoying.</P>

        <P>The facility object will do that work for you, in a single call, in addition to automatically adding other very useful information to the object. Here is an example of throwing an error defined by the <FacRef Ref="CIDLib"/> facility:</P>

        <Code>
        facCIDLib().ThrowErr
        (
            CID_FILE
            , CID_FILE
            , kCIDErrs::errcGen_IndexError
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::Index
            , TCardinal(c4Index)
            , clsThis()
            , TCardinal(c4MaxSize)
        );
        </Code>

        <P>The only change if we wanted to log this instead is in the method called, so logging this same error info would look like this:</P>

        <Code>
        facCIDLib().LogMsg
        (
            CID_FILE
            , CID_FILE
            , kCIDErrs::errcGen_IndexError
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::Index
            , TCardinal(c4Index)
            , clsThis()
            , TCardinal(c4MaxSize)
        );
        </Code>

        <P>Just going through the parameters in order, they are:</P>

        <List>
            <LItem Ref="Current File">Use CID_FILE to get the current source file name. This is set by the per-platform/build system tools during the compile.</LItem>
            <LItem Ref="Current Line">And similarly use CID_LINE to get the current line</LItem>
            <LItem Ref="Error Id">The error id comes from the error ids file generated by the build tool from the CIDLib_xx.MsgText file (see 'Facility Files' to the left.) The facility object will load the text for this error, and replace any tokens in it using the replacement values passed.</LItem>
            <LItem Ref="Severity">All exceptions are given a severity level. This is primarily used for log threshold filtering, which the facility object also does for you.</LItem>
            <LItem Ref="Error Class">All exceptions are given an error class. This is a broad indication of the family of error, in this case an index error.</LItem>
            <LItem Ref="Replacement Values">The rest of the parameters are replacement values to be put into the loaded text. The first one goes into the %(1) token, the next into %(2), etc... Up to four are supported.</LItem>
        </List>

        <Note>There are a few other variations of the method for specialized scenarios, so that you don't have to provide more info than needed.</Note>


        <SecTitle>Loadable Text</SecTitle>

        <P>As mentioned above, loadable text is associated with facilities. The English loadable text for the kCIDErrs::errcGen_IndexError thrown above is:</P>

        <Code>%(1) is not a valid index for the %(2) object. Count=%(3)</Code>

        <P>The first token is replaced by the index, the second by the class name of the class that threw the exception (via our RTTI system), and the last by the max size of the thing whose index bounds was exceeded. Note that the two numbers had to be passed as TCardinal objects, since the replacement parameters must be objects that implement the <ClassRef Ref="MFormattable"/> interface. So we can't directly pass the raw numbers.</P>


        <SecTitle>Stack Trace</SecTitle>

        <P>The exception/message class provides a stack track mechanism. Any code along the way can catch, add itself to the stack trace, and rethrow. This is encouraged at least for key paths through the call chain, because it helps tremendously with evaluating errors in the field. Doing it this way means we don't depend on any sort of dump from the system (and for the most part these would not be program ending errors anyway.) And the stack dump info gets naturally logged along with the other exception info where we can get to it without any user help or expertise.</P>

        <P>Here is an example. Of course the exception must be non-const for this:</P>

        <Code>
        try
        {
            // Do something, presumably bad
        }

        catch(TError&amp;amp; errToCatch)
        {
            errToCatch.AddStackLevel(CID_FILE, CID_LINE);
            throw;
        }
        </Code>

        <P>You don't need to, or really want to, do this in every method. But adding it at major points along the way allows you to have a feeling for the context in which an error occurred down in some general purpose code.</P>

        <P>Alternatively, we might choose to eat an exception as an internal detail, but log it for evaluation, in which case we might do this:</P>

        <Code>
        catch(TError&amp;amp; errToCatch)
        {
            errToCatch.AddStackLevel(CID_FILE, CID_LINE);
            TModule::LogEventObj(errToCatch);
            return kCIDLib::False;
        }
        return kCIDLib::True;
        </Code>

        <SecTitle>Error/Message Ids</SecTitle>

        <P>Of course, since the message/error id is just a number, the compiler will not tell you if you call ThrowErr/LogMsg on one facility object and pass it an id from another. It can't know you passed the wrong one. It will try to load the text with that numerical id from the target facility. That might fail, or it might just load the wrong text.</P>

        <P>One possible 'fix' for this would be to require each facility to have a specialized derivative that takes an enumerated error id and have the build tool generate the error and message ids to be enum class types. That would make for a compile time safe scheme. But it would be a big change and put more burden on each facility because there are a number of variations on the throwing/logging methods. It could be templatized presumably, but there are various issues to consider.</P>

        <P>So just exercise some caution in this area.</P>

        <Note>You can throw another facility's errors. The CIDLib facility provides a lot of general purpose errors you can throw. The exception/log message will show a facility name of CIDLib (since that's where the error comes from) but the file name and line number will be from your code, so it still gives you the info you need. So the above example of an error from CIDLib being thrown could have been called from anywhere.</Note>

        <SecTitle>Testing for Specific Errors</SecTitle>

        <P>In any general purpose code, typically you just cleanup and you are done. But, in higher level code you may sometimes want to check for specific errors. You do that, as you might imagine, by checking the facility name and error id, like this:</P>

        <Code>
        catch(const TError&amp;amp; errToCatch)
        {
            if (errToCatch.bCheckEvent(facCIDLib().strName(), kCIDErrs::errcGen_IndexError))
            {
                // It's the one we dreaded all along...
            }
        }
        </Code>


        <SecTitle>Providing Alternatives</SecTitle>

        <P>In many cases in CIDLib you will notice that a method has a trailing boolean parameter with a default value. It will be named generally 'bThrowIfNotXXX' or just 'bThrowIfNot'. The purpose of these parameters are to give you a choice as to whether you want to consider a failure in that method to be an exception type failure or if it should just return a status to indicate success or failure.</P>

        <P>In many cases which of these is most appropriate depends on the context, so we try not to necessarily force a specific scheme all the time. The called method will decide which default value makes the most sense for that type of call.</P>

        <P>Here is an example from the keyed has set collection class. TKey is a template parameter.</P>

        <Code>
        tCIDLib::TBoolean
        bRemoveKey( const   TKey&amp;amp;               objKeyToRemove
                    , const tCIDLib::TBoolean   bThrowIfNot = kCIDLib::True)
        </Code>

        <P>This method will remove a key from the hash set. Obviously sometimes this type of operation is just a 'remove it in case it exists' type deal, and in other cases it better damn well be there or something is majorly wrong. So you can choose how you want to react. The default in this case is to throw.</P>

    </HelpText>

</HelpPage>
