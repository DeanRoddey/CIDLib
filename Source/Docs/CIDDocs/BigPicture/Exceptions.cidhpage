<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE HelpPage PUBLIC "urn:charmedquark.com:CIDLib-Documentation.DTD" "CIDLibDocs.DTD">

<HelpPage>
    <Title>Exceptions in CIDLib</Title>

    <HelpText>

        <P>CIDLib most definitely uses exceptions, but it takes the (sane in my opinion) position that they should be used for exceptional things, not as a mechanism to unwind the stack. That doesn't mean it can only be used in case of the imminent end of the world, but it should only be used in places where something has really failed where it wouldn't be expected to be possible.</P>

        <P>CIDLib uses a single exception class, TError, unlike some systems which have an endless tree of derived specific exception types. No matter what you do, C++'s exception handling makes sometimes a bit annoying. But a single exception avoids the issues of how to react to different errors but still have common cleanup.</P>

        <P>Also, somewhat differently perhaps, you never directly throw these objects. Instead you call a method your facility object and it will build the object and throw it, doing a lot of work for you in the process. One particular reason for this is that it handles loading the text for the error code (and loadable resources are facility based.) But it also adds the facility name, and does token replacement in the loaded text. So it saves a lot of work.</P>

        <P>Here is an example of throwing an exception:</P>

        <Code>
        facCIDLib().ThrowErr
        (
            CID_FILE
            , CID_FILE
            , kCIDErrs::errcGen_IndexError
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::Index
            , TCardinal(c4Index)
            , clsThis()
            , TCardinal(c4MaxSize)
        );
        </Code>

        <P>Just going through the parameters in order, they are:</P>

        <List>
            <LItem Ref="Current File">Use CID_FILE to get the current source file name. This is set by the per-platform/build system tools during the compile.</LItem>
            <LItem Ref="Current Line">And similarly use CID_LINE to get the current line</LItem>
            <LItem Ref="Error Id">The error id comes from the error ids file generated by the build tool from the CIDLib_en.MsgText file (see 'Facility Files' to the left.) The facility object will load the text for this error.</LItem>
            <LItem Ref="Severity">All exceptions are given a severity level. This is primarily used for log threshold filtering, which the facility object also does for you.</LItem>
            <LItem Ref="Error Class">All exceptions are given an error class. This is a broad indication of the family of error, in this case an index error.</LItem>
            <LItem Ref="Replacement Tokens">The rest of the parameters are replacement tokens to be put into the loaded text. The first one goes into %(1), the next into %(2), etc... Up to four are supported.</LItem>
        </List>

        <Note>There are a few variations of the method for specialized scenarios, so that you don't have to provide more info than needed.</Note>

        <SecTitle>Loadable Text</SecTitle>

        <P>As mentioned above, loadable text is associated with facilities. The English loadable text for the kCIDErrs::errcGen_IndexError throw above is:</P>

        <Code>%(1) is not a valid index for the %(2) object. Count=%(3)</Code>

        <P>The first token is replaced by the index, the second by the class name of the class that threw the exception (via our RTTI system), and the last by the max size of the thing whose index bounds was exceeded. Note that the two numbers had to be passed as TCardinal values, since the replacement parameters must be objects that implement the MFormattable interface. For booleans you'd use TBoolean, for floats TFloat, for integers TInteger.</P>

        <SecTitle>Logging Errors/Messages</SecTitle>

        <P>In actual fact there is no TError class. That is just an alias for the class TLogEvent. In CIDLib, errors and message logging are very much tied together and work much the same. So they use the same class under the hood. This also makes it very simple to log exceptions since they already are the loggable message type.</P>

        <P>As with throwing, you call a method on the facility object. All it would take to change the above throwing of an exception to the logging of a message would be to change ThrowErr() to LogMsg().</P>

        <SecTitle>Stack Trace</SecTitle>

        <P>The exception class provides a stack track mechanism. Any code along the way can catch, add itself to the stack trace, and rethrow. This is encouraged at least for key paths through the call chain, because it helps tremendously with evaluating errors in the field. We don't depend on any sort of dump from the system (and for the most part these would not be programming ending errors anyway.) And the stack dump info gets naturally logged along with the other exception info where we can get to it without any user help or expertise.</P>

        <P>Here is an example. Of course the exception must be non-const for this:</P>

        <Code>
        try
        {
            // Do something, presumably bad
        }

        catch(TError&amp;amp; errToCatch)
        {
            errToCatch.AddStackLevel(CID_FILE, CID_LINE);
            throw;
        }
        </Code>

        <P>You don't need to, or really want to, do this in every method. But adding it at major points along the way allows you to have a feeling for the context in which an error occurred down in some general purpose code.</P>

        <SecTitle>Error Ids</SecTitle>

        <P>Of course, since the error id is just a number, the compiler will not tell you if you call ThrowErr/LogMsg on one facility object and pass it an error id from another. It can't know you passed the wrong one. It will try to load a msg with that numerical id from the target facility.</P>

        <P>One possible 'fix' for this would be to require each facility to have a specialized derivative that takes an enumerated error id and have the build tool generate the error and message ids to be enum class types. That would make for a compile time safe scheme. But it would be a big change and put more burden on each facility because there are a number of variations on the throwing/logging methods. It could be templatized presumably, but there are various issues to consider.</P>

        <P>So just exercise some caution in this area.</P>

        <Note>You can throw another facility's errors. The CIDLib facility provides a lot of general purpose errors you can throw. The exception/log message will show a facility name of CIDLib (since that's where the error comes from) but the file name and line number will be from your code, so it still gives you the info you need. So the above example of an error from CIDLib being thrown could have been called from anywhere.</Note>

        <SecTitle>Testing for Specific Errors</SecTitle>

        <P>In any general purpose code, typically you just cleanup and you are done. But, in higher level code you may sometimes want to check for specific errors. You do that, as you might imagine, by checking the facility name and error id, like this:</P>

        <Code>
        catch(const TError&amp;amp; errToCatch)
        {
            if (errToCatch.bCheckEvent(facCIDLib().strName(), kCIDErrs::errcGen_IndexError))
            {
                // It's the one we dreaded all along...
            }
        }
        </Code>


        <SecTitle>Providing Alternatives</SecTitle>

        <P>In many cases in CIDLib you will notice that a method has a trailing boolean parameter with a default value. It will be named generally 'bThrowIfNotXXX' or just 'bThrowIfNot'. The purpose of these parameters are to give you a choice as to whether you want to consider a failure in that method to be an exception type failure or if it should just return a status to indicate success or failure.</P>

        <P>In many cases which of these is most appropriate depends on the context, so we try not to necessarily force a specific scheme all the time. The called method will decide which default value makes the most sense for that type of call.</P>

        <P>Here is an example from the keyed has set collection class. TKey is a template parameter.</P>

        <Code>
        tCIDLib::TBoolean
        bRemoveKey( const   TKey&amp;amp;               objKeyToRemove
                    , const tCIDLib::TBoolean   bThrowIfNot = kCIDLib::True)
        </Code>

        <P>This method will remove a key from the hash set. Obviously sometimes this type of operation is just a 'remove it in case it exists' type deal, and in other cases it better damn well be there or something is majorly wrong. So you can choose how you want to react. The default in this case is to throw.</P>

    </HelpText>

</HelpPage>
